// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'app_navigation_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AppNavigationEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() navigateToHome,
    required TResult Function() navigateToSearch,
    required TResult Function(BuildContext context) navigateToScan,
    required TResult Function() navigateToPrediction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? navigateToHome,
    TResult? Function()? navigateToSearch,
    TResult? Function(BuildContext context)? navigateToScan,
    TResult? Function()? navigateToPrediction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? navigateToHome,
    TResult Function()? navigateToSearch,
    TResult Function(BuildContext context)? navigateToScan,
    TResult Function()? navigateToPrediction,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_NavigateToHome value) navigateToHome,
    required TResult Function(_NavigateToSearch value) navigateToSearch,
    required TResult Function(_NavigateToScan value) navigateToScan,
    required TResult Function(_NavigateToPrediction value) navigateToPrediction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_NavigateToHome value)? navigateToHome,
    TResult? Function(_NavigateToSearch value)? navigateToSearch,
    TResult? Function(_NavigateToScan value)? navigateToScan,
    TResult? Function(_NavigateToPrediction value)? navigateToPrediction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_NavigateToHome value)? navigateToHome,
    TResult Function(_NavigateToSearch value)? navigateToSearch,
    TResult Function(_NavigateToScan value)? navigateToScan,
    TResult Function(_NavigateToPrediction value)? navigateToPrediction,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppNavigationEventCopyWith<$Res> {
  factory $AppNavigationEventCopyWith(
          AppNavigationEvent value, $Res Function(AppNavigationEvent) then) =
      _$AppNavigationEventCopyWithImpl<$Res, AppNavigationEvent>;
}

/// @nodoc
class _$AppNavigationEventCopyWithImpl<$Res, $Val extends AppNavigationEvent>
    implements $AppNavigationEventCopyWith<$Res> {
  _$AppNavigationEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$StartedImplCopyWith<$Res> {
  factory _$$StartedImplCopyWith(
          _$StartedImpl value, $Res Function(_$StartedImpl) then) =
      __$$StartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartedImplCopyWithImpl<$Res>
    extends _$AppNavigationEventCopyWithImpl<$Res, _$StartedImpl>
    implements _$$StartedImplCopyWith<$Res> {
  __$$StartedImplCopyWithImpl(
      _$StartedImpl _value, $Res Function(_$StartedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$StartedImpl with DiagnosticableTreeMixin implements _Started {
  const _$StartedImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AppNavigationEvent.started()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'AppNavigationEvent.started'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() navigateToHome,
    required TResult Function() navigateToSearch,
    required TResult Function(BuildContext context) navigateToScan,
    required TResult Function() navigateToPrediction,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? navigateToHome,
    TResult? Function()? navigateToSearch,
    TResult? Function(BuildContext context)? navigateToScan,
    TResult? Function()? navigateToPrediction,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? navigateToHome,
    TResult Function()? navigateToSearch,
    TResult Function(BuildContext context)? navigateToScan,
    TResult Function()? navigateToPrediction,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_NavigateToHome value) navigateToHome,
    required TResult Function(_NavigateToSearch value) navigateToSearch,
    required TResult Function(_NavigateToScan value) navigateToScan,
    required TResult Function(_NavigateToPrediction value) navigateToPrediction,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_NavigateToHome value)? navigateToHome,
    TResult? Function(_NavigateToSearch value)? navigateToSearch,
    TResult? Function(_NavigateToScan value)? navigateToScan,
    TResult? Function(_NavigateToPrediction value)? navigateToPrediction,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_NavigateToHome value)? navigateToHome,
    TResult Function(_NavigateToSearch value)? navigateToSearch,
    TResult Function(_NavigateToScan value)? navigateToScan,
    TResult Function(_NavigateToPrediction value)? navigateToPrediction,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _Started implements AppNavigationEvent {
  const factory _Started() = _$StartedImpl;
}

/// @nodoc
abstract class _$$NavigateToHomeImplCopyWith<$Res> {
  factory _$$NavigateToHomeImplCopyWith(_$NavigateToHomeImpl value,
          $Res Function(_$NavigateToHomeImpl) then) =
      __$$NavigateToHomeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NavigateToHomeImplCopyWithImpl<$Res>
    extends _$AppNavigationEventCopyWithImpl<$Res, _$NavigateToHomeImpl>
    implements _$$NavigateToHomeImplCopyWith<$Res> {
  __$$NavigateToHomeImplCopyWithImpl(
      _$NavigateToHomeImpl _value, $Res Function(_$NavigateToHomeImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NavigateToHomeImpl
    with DiagnosticableTreeMixin
    implements _NavigateToHome {
  const _$NavigateToHomeImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AppNavigationEvent.navigateToHome()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'AppNavigationEvent.navigateToHome'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NavigateToHomeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() navigateToHome,
    required TResult Function() navigateToSearch,
    required TResult Function(BuildContext context) navigateToScan,
    required TResult Function() navigateToPrediction,
  }) {
    return navigateToHome();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? navigateToHome,
    TResult? Function()? navigateToSearch,
    TResult? Function(BuildContext context)? navigateToScan,
    TResult? Function()? navigateToPrediction,
  }) {
    return navigateToHome?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? navigateToHome,
    TResult Function()? navigateToSearch,
    TResult Function(BuildContext context)? navigateToScan,
    TResult Function()? navigateToPrediction,
    required TResult orElse(),
  }) {
    if (navigateToHome != null) {
      return navigateToHome();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_NavigateToHome value) navigateToHome,
    required TResult Function(_NavigateToSearch value) navigateToSearch,
    required TResult Function(_NavigateToScan value) navigateToScan,
    required TResult Function(_NavigateToPrediction value) navigateToPrediction,
  }) {
    return navigateToHome(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_NavigateToHome value)? navigateToHome,
    TResult? Function(_NavigateToSearch value)? navigateToSearch,
    TResult? Function(_NavigateToScan value)? navigateToScan,
    TResult? Function(_NavigateToPrediction value)? navigateToPrediction,
  }) {
    return navigateToHome?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_NavigateToHome value)? navigateToHome,
    TResult Function(_NavigateToSearch value)? navigateToSearch,
    TResult Function(_NavigateToScan value)? navigateToScan,
    TResult Function(_NavigateToPrediction value)? navigateToPrediction,
    required TResult orElse(),
  }) {
    if (navigateToHome != null) {
      return navigateToHome(this);
    }
    return orElse();
  }
}

abstract class _NavigateToHome implements AppNavigationEvent {
  const factory _NavigateToHome() = _$NavigateToHomeImpl;
}

/// @nodoc
abstract class _$$NavigateToSearchImplCopyWith<$Res> {
  factory _$$NavigateToSearchImplCopyWith(_$NavigateToSearchImpl value,
          $Res Function(_$NavigateToSearchImpl) then) =
      __$$NavigateToSearchImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NavigateToSearchImplCopyWithImpl<$Res>
    extends _$AppNavigationEventCopyWithImpl<$Res, _$NavigateToSearchImpl>
    implements _$$NavigateToSearchImplCopyWith<$Res> {
  __$$NavigateToSearchImplCopyWithImpl(_$NavigateToSearchImpl _value,
      $Res Function(_$NavigateToSearchImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NavigateToSearchImpl
    with DiagnosticableTreeMixin
    implements _NavigateToSearch {
  const _$NavigateToSearchImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AppNavigationEvent.navigateToSearch()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(
        DiagnosticsProperty('type', 'AppNavigationEvent.navigateToSearch'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NavigateToSearchImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() navigateToHome,
    required TResult Function() navigateToSearch,
    required TResult Function(BuildContext context) navigateToScan,
    required TResult Function() navigateToPrediction,
  }) {
    return navigateToSearch();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? navigateToHome,
    TResult? Function()? navigateToSearch,
    TResult? Function(BuildContext context)? navigateToScan,
    TResult? Function()? navigateToPrediction,
  }) {
    return navigateToSearch?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? navigateToHome,
    TResult Function()? navigateToSearch,
    TResult Function(BuildContext context)? navigateToScan,
    TResult Function()? navigateToPrediction,
    required TResult orElse(),
  }) {
    if (navigateToSearch != null) {
      return navigateToSearch();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_NavigateToHome value) navigateToHome,
    required TResult Function(_NavigateToSearch value) navigateToSearch,
    required TResult Function(_NavigateToScan value) navigateToScan,
    required TResult Function(_NavigateToPrediction value) navigateToPrediction,
  }) {
    return navigateToSearch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_NavigateToHome value)? navigateToHome,
    TResult? Function(_NavigateToSearch value)? navigateToSearch,
    TResult? Function(_NavigateToScan value)? navigateToScan,
    TResult? Function(_NavigateToPrediction value)? navigateToPrediction,
  }) {
    return navigateToSearch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_NavigateToHome value)? navigateToHome,
    TResult Function(_NavigateToSearch value)? navigateToSearch,
    TResult Function(_NavigateToScan value)? navigateToScan,
    TResult Function(_NavigateToPrediction value)? navigateToPrediction,
    required TResult orElse(),
  }) {
    if (navigateToSearch != null) {
      return navigateToSearch(this);
    }
    return orElse();
  }
}

abstract class _NavigateToSearch implements AppNavigationEvent {
  const factory _NavigateToSearch() = _$NavigateToSearchImpl;
}

/// @nodoc
abstract class _$$NavigateToScanImplCopyWith<$Res> {
  factory _$$NavigateToScanImplCopyWith(_$NavigateToScanImpl value,
          $Res Function(_$NavigateToScanImpl) then) =
      __$$NavigateToScanImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BuildContext context});
}

/// @nodoc
class __$$NavigateToScanImplCopyWithImpl<$Res>
    extends _$AppNavigationEventCopyWithImpl<$Res, _$NavigateToScanImpl>
    implements _$$NavigateToScanImplCopyWith<$Res> {
  __$$NavigateToScanImplCopyWithImpl(
      _$NavigateToScanImpl _value, $Res Function(_$NavigateToScanImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? context = null,
  }) {
    return _then(_$NavigateToScanImpl(
      null == context
          ? _value.context
          : context // ignore: cast_nullable_to_non_nullable
              as BuildContext,
    ));
  }
}

/// @nodoc

class _$NavigateToScanImpl
    with DiagnosticableTreeMixin
    implements _NavigateToScan {
  const _$NavigateToScanImpl(this.context);

  @override
  final BuildContext context;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AppNavigationEvent.navigateToScan(context: $context)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AppNavigationEvent.navigateToScan'))
      ..add(DiagnosticsProperty('context', context));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NavigateToScanImpl &&
            (identical(other.context, context) || other.context == context));
  }

  @override
  int get hashCode => Object.hash(runtimeType, context);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NavigateToScanImplCopyWith<_$NavigateToScanImpl> get copyWith =>
      __$$NavigateToScanImplCopyWithImpl<_$NavigateToScanImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() navigateToHome,
    required TResult Function() navigateToSearch,
    required TResult Function(BuildContext context) navigateToScan,
    required TResult Function() navigateToPrediction,
  }) {
    return navigateToScan(context);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? navigateToHome,
    TResult? Function()? navigateToSearch,
    TResult? Function(BuildContext context)? navigateToScan,
    TResult? Function()? navigateToPrediction,
  }) {
    return navigateToScan?.call(context);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? navigateToHome,
    TResult Function()? navigateToSearch,
    TResult Function(BuildContext context)? navigateToScan,
    TResult Function()? navigateToPrediction,
    required TResult orElse(),
  }) {
    if (navigateToScan != null) {
      return navigateToScan(context);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_NavigateToHome value) navigateToHome,
    required TResult Function(_NavigateToSearch value) navigateToSearch,
    required TResult Function(_NavigateToScan value) navigateToScan,
    required TResult Function(_NavigateToPrediction value) navigateToPrediction,
  }) {
    return navigateToScan(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_NavigateToHome value)? navigateToHome,
    TResult? Function(_NavigateToSearch value)? navigateToSearch,
    TResult? Function(_NavigateToScan value)? navigateToScan,
    TResult? Function(_NavigateToPrediction value)? navigateToPrediction,
  }) {
    return navigateToScan?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_NavigateToHome value)? navigateToHome,
    TResult Function(_NavigateToSearch value)? navigateToSearch,
    TResult Function(_NavigateToScan value)? navigateToScan,
    TResult Function(_NavigateToPrediction value)? navigateToPrediction,
    required TResult orElse(),
  }) {
    if (navigateToScan != null) {
      return navigateToScan(this);
    }
    return orElse();
  }
}

abstract class _NavigateToScan implements AppNavigationEvent {
  const factory _NavigateToScan(final BuildContext context) =
      _$NavigateToScanImpl;

  BuildContext get context;
  @JsonKey(ignore: true)
  _$$NavigateToScanImplCopyWith<_$NavigateToScanImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NavigateToPredictionImplCopyWith<$Res> {
  factory _$$NavigateToPredictionImplCopyWith(_$NavigateToPredictionImpl value,
          $Res Function(_$NavigateToPredictionImpl) then) =
      __$$NavigateToPredictionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NavigateToPredictionImplCopyWithImpl<$Res>
    extends _$AppNavigationEventCopyWithImpl<$Res, _$NavigateToPredictionImpl>
    implements _$$NavigateToPredictionImplCopyWith<$Res> {
  __$$NavigateToPredictionImplCopyWithImpl(_$NavigateToPredictionImpl _value,
      $Res Function(_$NavigateToPredictionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NavigateToPredictionImpl
    with DiagnosticableTreeMixin
    implements _NavigateToPrediction {
  const _$NavigateToPredictionImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AppNavigationEvent.navigateToPrediction()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(
        DiagnosticsProperty('type', 'AppNavigationEvent.navigateToPrediction'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NavigateToPredictionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() navigateToHome,
    required TResult Function() navigateToSearch,
    required TResult Function(BuildContext context) navigateToScan,
    required TResult Function() navigateToPrediction,
  }) {
    return navigateToPrediction();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? navigateToHome,
    TResult? Function()? navigateToSearch,
    TResult? Function(BuildContext context)? navigateToScan,
    TResult? Function()? navigateToPrediction,
  }) {
    return navigateToPrediction?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? navigateToHome,
    TResult Function()? navigateToSearch,
    TResult Function(BuildContext context)? navigateToScan,
    TResult Function()? navigateToPrediction,
    required TResult orElse(),
  }) {
    if (navigateToPrediction != null) {
      return navigateToPrediction();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_NavigateToHome value) navigateToHome,
    required TResult Function(_NavigateToSearch value) navigateToSearch,
    required TResult Function(_NavigateToScan value) navigateToScan,
    required TResult Function(_NavigateToPrediction value) navigateToPrediction,
  }) {
    return navigateToPrediction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_NavigateToHome value)? navigateToHome,
    TResult? Function(_NavigateToSearch value)? navigateToSearch,
    TResult? Function(_NavigateToScan value)? navigateToScan,
    TResult? Function(_NavigateToPrediction value)? navigateToPrediction,
  }) {
    return navigateToPrediction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_NavigateToHome value)? navigateToHome,
    TResult Function(_NavigateToSearch value)? navigateToSearch,
    TResult Function(_NavigateToScan value)? navigateToScan,
    TResult Function(_NavigateToPrediction value)? navigateToPrediction,
    required TResult orElse(),
  }) {
    if (navigateToPrediction != null) {
      return navigateToPrediction(this);
    }
    return orElse();
  }
}

abstract class _NavigateToPrediction implements AppNavigationEvent {
  const factory _NavigateToPrediction() = _$NavigateToPredictionImpl;
}

/// @nodoc
mixin _$AppNavigationState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(String currenttitle) home,
    required TResult Function(String currenttitle) search,
    required TResult Function(String? barcode) scan,
    required TResult Function(String currenttitle) prediction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(String currenttitle)? home,
    TResult? Function(String currenttitle)? search,
    TResult? Function(String? barcode)? scan,
    TResult? Function(String currenttitle)? prediction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(String currenttitle)? home,
    TResult Function(String currenttitle)? search,
    TResult Function(String? barcode)? scan,
    TResult Function(String currenttitle)? prediction,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Home value) home,
    required TResult Function(_Search value) search,
    required TResult Function(_Scan value) scan,
    required TResult Function(_prediction value) prediction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Home value)? home,
    TResult? Function(_Search value)? search,
    TResult? Function(_Scan value)? scan,
    TResult? Function(_prediction value)? prediction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Home value)? home,
    TResult Function(_Search value)? search,
    TResult Function(_Scan value)? scan,
    TResult Function(_prediction value)? prediction,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppNavigationStateCopyWith<$Res> {
  factory $AppNavigationStateCopyWith(
          AppNavigationState value, $Res Function(AppNavigationState) then) =
      _$AppNavigationStateCopyWithImpl<$Res, AppNavigationState>;
}

/// @nodoc
class _$AppNavigationStateCopyWithImpl<$Res, $Val extends AppNavigationState>
    implements $AppNavigationStateCopyWith<$Res> {
  _$AppNavigationStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$AppNavigationStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl with DiagnosticableTreeMixin implements _Initial {
  const _$InitialImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AppNavigationState.initial()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'AppNavigationState.initial'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(String currenttitle) home,
    required TResult Function(String currenttitle) search,
    required TResult Function(String? barcode) scan,
    required TResult Function(String currenttitle) prediction,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(String currenttitle)? home,
    TResult? Function(String currenttitle)? search,
    TResult? Function(String? barcode)? scan,
    TResult? Function(String currenttitle)? prediction,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(String currenttitle)? home,
    TResult Function(String currenttitle)? search,
    TResult Function(String? barcode)? scan,
    TResult Function(String currenttitle)? prediction,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Home value) home,
    required TResult Function(_Search value) search,
    required TResult Function(_Scan value) scan,
    required TResult Function(_prediction value) prediction,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Home value)? home,
    TResult? Function(_Search value)? search,
    TResult? Function(_Scan value)? scan,
    TResult? Function(_prediction value)? prediction,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Home value)? home,
    TResult Function(_Search value)? search,
    TResult Function(_Scan value)? scan,
    TResult Function(_prediction value)? prediction,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements AppNavigationState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$HomeImplCopyWith<$Res> {
  factory _$$HomeImplCopyWith(
          _$HomeImpl value, $Res Function(_$HomeImpl) then) =
      __$$HomeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String currenttitle});
}

/// @nodoc
class __$$HomeImplCopyWithImpl<$Res>
    extends _$AppNavigationStateCopyWithImpl<$Res, _$HomeImpl>
    implements _$$HomeImplCopyWith<$Res> {
  __$$HomeImplCopyWithImpl(_$HomeImpl _value, $Res Function(_$HomeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currenttitle = null,
  }) {
    return _then(_$HomeImpl(
      currenttitle: null == currenttitle
          ? _value.currenttitle
          : currenttitle // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$HomeImpl with DiagnosticableTreeMixin implements _Home {
  const _$HomeImpl({required this.currenttitle});

  @override
  final String currenttitle;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AppNavigationState.home(currenttitle: $currenttitle)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AppNavigationState.home'))
      ..add(DiagnosticsProperty('currenttitle', currenttitle));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HomeImpl &&
            (identical(other.currenttitle, currenttitle) ||
                other.currenttitle == currenttitle));
  }

  @override
  int get hashCode => Object.hash(runtimeType, currenttitle);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HomeImplCopyWith<_$HomeImpl> get copyWith =>
      __$$HomeImplCopyWithImpl<_$HomeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(String currenttitle) home,
    required TResult Function(String currenttitle) search,
    required TResult Function(String? barcode) scan,
    required TResult Function(String currenttitle) prediction,
  }) {
    return home(currenttitle);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(String currenttitle)? home,
    TResult? Function(String currenttitle)? search,
    TResult? Function(String? barcode)? scan,
    TResult? Function(String currenttitle)? prediction,
  }) {
    return home?.call(currenttitle);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(String currenttitle)? home,
    TResult Function(String currenttitle)? search,
    TResult Function(String? barcode)? scan,
    TResult Function(String currenttitle)? prediction,
    required TResult orElse(),
  }) {
    if (home != null) {
      return home(currenttitle);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Home value) home,
    required TResult Function(_Search value) search,
    required TResult Function(_Scan value) scan,
    required TResult Function(_prediction value) prediction,
  }) {
    return home(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Home value)? home,
    TResult? Function(_Search value)? search,
    TResult? Function(_Scan value)? scan,
    TResult? Function(_prediction value)? prediction,
  }) {
    return home?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Home value)? home,
    TResult Function(_Search value)? search,
    TResult Function(_Scan value)? scan,
    TResult Function(_prediction value)? prediction,
    required TResult orElse(),
  }) {
    if (home != null) {
      return home(this);
    }
    return orElse();
  }
}

abstract class _Home implements AppNavigationState {
  const factory _Home({required final String currenttitle}) = _$HomeImpl;

  String get currenttitle;
  @JsonKey(ignore: true)
  _$$HomeImplCopyWith<_$HomeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SearchImplCopyWith<$Res> {
  factory _$$SearchImplCopyWith(
          _$SearchImpl value, $Res Function(_$SearchImpl) then) =
      __$$SearchImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String currenttitle});
}

/// @nodoc
class __$$SearchImplCopyWithImpl<$Res>
    extends _$AppNavigationStateCopyWithImpl<$Res, _$SearchImpl>
    implements _$$SearchImplCopyWith<$Res> {
  __$$SearchImplCopyWithImpl(
      _$SearchImpl _value, $Res Function(_$SearchImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currenttitle = null,
  }) {
    return _then(_$SearchImpl(
      currenttitle: null == currenttitle
          ? _value.currenttitle
          : currenttitle // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SearchImpl with DiagnosticableTreeMixin implements _Search {
  const _$SearchImpl({required this.currenttitle});

  @override
  final String currenttitle;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AppNavigationState.search(currenttitle: $currenttitle)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AppNavigationState.search'))
      ..add(DiagnosticsProperty('currenttitle', currenttitle));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchImpl &&
            (identical(other.currenttitle, currenttitle) ||
                other.currenttitle == currenttitle));
  }

  @override
  int get hashCode => Object.hash(runtimeType, currenttitle);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SearchImplCopyWith<_$SearchImpl> get copyWith =>
      __$$SearchImplCopyWithImpl<_$SearchImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(String currenttitle) home,
    required TResult Function(String currenttitle) search,
    required TResult Function(String? barcode) scan,
    required TResult Function(String currenttitle) prediction,
  }) {
    return search(currenttitle);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(String currenttitle)? home,
    TResult? Function(String currenttitle)? search,
    TResult? Function(String? barcode)? scan,
    TResult? Function(String currenttitle)? prediction,
  }) {
    return search?.call(currenttitle);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(String currenttitle)? home,
    TResult Function(String currenttitle)? search,
    TResult Function(String? barcode)? scan,
    TResult Function(String currenttitle)? prediction,
    required TResult orElse(),
  }) {
    if (search != null) {
      return search(currenttitle);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Home value) home,
    required TResult Function(_Search value) search,
    required TResult Function(_Scan value) scan,
    required TResult Function(_prediction value) prediction,
  }) {
    return search(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Home value)? home,
    TResult? Function(_Search value)? search,
    TResult? Function(_Scan value)? scan,
    TResult? Function(_prediction value)? prediction,
  }) {
    return search?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Home value)? home,
    TResult Function(_Search value)? search,
    TResult Function(_Scan value)? scan,
    TResult Function(_prediction value)? prediction,
    required TResult orElse(),
  }) {
    if (search != null) {
      return search(this);
    }
    return orElse();
  }
}

abstract class _Search implements AppNavigationState {
  const factory _Search({required final String currenttitle}) = _$SearchImpl;

  String get currenttitle;
  @JsonKey(ignore: true)
  _$$SearchImplCopyWith<_$SearchImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ScanImplCopyWith<$Res> {
  factory _$$ScanImplCopyWith(
          _$ScanImpl value, $Res Function(_$ScanImpl) then) =
      __$$ScanImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? barcode});
}

/// @nodoc
class __$$ScanImplCopyWithImpl<$Res>
    extends _$AppNavigationStateCopyWithImpl<$Res, _$ScanImpl>
    implements _$$ScanImplCopyWith<$Res> {
  __$$ScanImplCopyWithImpl(_$ScanImpl _value, $Res Function(_$ScanImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? barcode = freezed,
  }) {
    return _then(_$ScanImpl(
      barcode: freezed == barcode
          ? _value.barcode
          : barcode // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ScanImpl with DiagnosticableTreeMixin implements _Scan {
  const _$ScanImpl({required this.barcode});

  @override
  final String? barcode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AppNavigationState.scan(barcode: $barcode)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AppNavigationState.scan'))
      ..add(DiagnosticsProperty('barcode', barcode));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ScanImpl &&
            (identical(other.barcode, barcode) || other.barcode == barcode));
  }

  @override
  int get hashCode => Object.hash(runtimeType, barcode);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ScanImplCopyWith<_$ScanImpl> get copyWith =>
      __$$ScanImplCopyWithImpl<_$ScanImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(String currenttitle) home,
    required TResult Function(String currenttitle) search,
    required TResult Function(String? barcode) scan,
    required TResult Function(String currenttitle) prediction,
  }) {
    return scan(barcode);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(String currenttitle)? home,
    TResult? Function(String currenttitle)? search,
    TResult? Function(String? barcode)? scan,
    TResult? Function(String currenttitle)? prediction,
  }) {
    return scan?.call(barcode);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(String currenttitle)? home,
    TResult Function(String currenttitle)? search,
    TResult Function(String? barcode)? scan,
    TResult Function(String currenttitle)? prediction,
    required TResult orElse(),
  }) {
    if (scan != null) {
      return scan(barcode);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Home value) home,
    required TResult Function(_Search value) search,
    required TResult Function(_Scan value) scan,
    required TResult Function(_prediction value) prediction,
  }) {
    return scan(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Home value)? home,
    TResult? Function(_Search value)? search,
    TResult? Function(_Scan value)? scan,
    TResult? Function(_prediction value)? prediction,
  }) {
    return scan?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Home value)? home,
    TResult Function(_Search value)? search,
    TResult Function(_Scan value)? scan,
    TResult Function(_prediction value)? prediction,
    required TResult orElse(),
  }) {
    if (scan != null) {
      return scan(this);
    }
    return orElse();
  }
}

abstract class _Scan implements AppNavigationState {
  const factory _Scan({required final String? barcode}) = _$ScanImpl;

  String? get barcode;
  @JsonKey(ignore: true)
  _$$ScanImplCopyWith<_$ScanImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$predictionImplCopyWith<$Res> {
  factory _$$predictionImplCopyWith(
          _$predictionImpl value, $Res Function(_$predictionImpl) then) =
      __$$predictionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String currenttitle});
}

/// @nodoc
class __$$predictionImplCopyWithImpl<$Res>
    extends _$AppNavigationStateCopyWithImpl<$Res, _$predictionImpl>
    implements _$$predictionImplCopyWith<$Res> {
  __$$predictionImplCopyWithImpl(
      _$predictionImpl _value, $Res Function(_$predictionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currenttitle = null,
  }) {
    return _then(_$predictionImpl(
      currenttitle: null == currenttitle
          ? _value.currenttitle
          : currenttitle // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$predictionImpl with DiagnosticableTreeMixin implements _prediction {
  const _$predictionImpl({required this.currenttitle});

  @override
  final String currenttitle;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AppNavigationState.prediction(currenttitle: $currenttitle)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AppNavigationState.prediction'))
      ..add(DiagnosticsProperty('currenttitle', currenttitle));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$predictionImpl &&
            (identical(other.currenttitle, currenttitle) ||
                other.currenttitle == currenttitle));
  }

  @override
  int get hashCode => Object.hash(runtimeType, currenttitle);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$predictionImplCopyWith<_$predictionImpl> get copyWith =>
      __$$predictionImplCopyWithImpl<_$predictionImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(String currenttitle) home,
    required TResult Function(String currenttitle) search,
    required TResult Function(String? barcode) scan,
    required TResult Function(String currenttitle) prediction,
  }) {
    return prediction(currenttitle);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(String currenttitle)? home,
    TResult? Function(String currenttitle)? search,
    TResult? Function(String? barcode)? scan,
    TResult? Function(String currenttitle)? prediction,
  }) {
    return prediction?.call(currenttitle);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(String currenttitle)? home,
    TResult Function(String currenttitle)? search,
    TResult Function(String? barcode)? scan,
    TResult Function(String currenttitle)? prediction,
    required TResult orElse(),
  }) {
    if (prediction != null) {
      return prediction(currenttitle);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Home value) home,
    required TResult Function(_Search value) search,
    required TResult Function(_Scan value) scan,
    required TResult Function(_prediction value) prediction,
  }) {
    return prediction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Home value)? home,
    TResult? Function(_Search value)? search,
    TResult? Function(_Scan value)? scan,
    TResult? Function(_prediction value)? prediction,
  }) {
    return prediction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Home value)? home,
    TResult Function(_Search value)? search,
    TResult Function(_Scan value)? scan,
    TResult Function(_prediction value)? prediction,
    required TResult orElse(),
  }) {
    if (prediction != null) {
      return prediction(this);
    }
    return orElse();
  }
}

abstract class _prediction implements AppNavigationState {
  const factory _prediction({required final String currenttitle}) =
      _$predictionImpl;

  String get currenttitle;
  @JsonKey(ignore: true)
  _$$predictionImplCopyWith<_$predictionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
